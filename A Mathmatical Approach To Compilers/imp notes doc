DONE 17th:
caching for Church numerals (faster + less memory churn)
cleaner lambda parsing (single arg + multiple args)
church booleans + if
parser errors with line/col tracking.


DONE font end:
DONE- Source code is written in a Lisp-like S-expression syntax (.lctest)
DONE - Produces an AST of S-expressions (SExpr), which are either atoms (symbols/numbers) or lists.
DONE - Parentheses define structure, avoiding operator-precedence rules.
DONE - Error reporting: Tokens carry line/column metadata so errors are surfaced with helpful locations.
DONE - Rationale: S-expressions are a natural surface syntax for lambda calculus; minimal parsing logic is needed, reducing complexity in the front end.


DONE translator:
DONE    - Church numerals:
Done        - integers are church numerals (λf.λx.f(f(...(x))))
DONE        - boolean church numerals (λt.λf.t / λt.λf.f)
DONE        - operators:
DONE            Addition → λm.λn.λf.λx. m f (n f x)
DONE            Multiplication → λm.λn.λf. m (n f)
DONE        - Special forms:
DONE            (lambda (x y) body) → curried λ-terms.
DONE            (if cond then else) → (cond then else).
DONE        - Application:
DONE            Any list (f a b c) → (((f a) b) c).
DONE        - Rationale:
DONE            By translating all constructs into pure λ-terms, the IR is uniform and higher-      order by construction. This eliminates the need for primitive integer or boolean types in the IR.

DONE- Optmisation:
DONE    -Problem: Naively expanding large integers produces massive strings (e.g., 1000 → 2000 nested function calls).
DONE    - Solution: Cache λ-term encodings of numerals in a hash table (std::unordered_map<int, std::string>).
DONE    - Benefit: Avoids recomputation, reduces IR size for repeated constants.
DONE    - Rationale: Caching reflects a common compiler practice: reusing IR fragments instead of regenerating them. In a real optimizing compiler, this would be analogous to common subexpression elimination.

DONE: Uniform IR Model:
DONE- All constructs (numbers, booleans, control flow, functions) reduce to function application.
DONE- IR is fully higher-order, supporting:
    DONE- Functions as values.
    DONE- Function composition and currying natively.
DONE- Control constructs (like if) are expressed as functions rather than special opcodes.
DONE- Rationale: Unlike typical compiler IRs (e.g., SSA, TAC, or bytecode) which mix primitives and instructions, the λ-calculus IR uses a single abstraction mechanism — the λ-term. This unification makes it conceptually simpler, at the cost of verbosity.

DONEExtensibility:
DONE- New constructs can be added by encoding them as macros in λ-calculus:
DONE    let → ( (λx. body) value )
DONE    Pairs → λf. f a b
DONE    Recursion → via the Y combinator.
DONE- Rationale: Because the IR is Turing-complete, any language feature can be lowered into λ-calculus without extending the IR’s semantics. This makes it a "minimal but universal" target.






































Comparison to Traditional IRs:
- SSA / TAC: Typically imperative, with explicit temporaries, jumps, and control flow graphs.
- λ-calculus IR: Declarative, expression-oriented, with no explicit control flow — only function application.
- Implication: Optimization techniques (inlining, common subexpression elimination, deforestation) can be expressed as λ-calculus transformations.

Implementation Challenges:
- Readability: Translated λ-terms become large and unreadable quickly.
- Performance: Naive β-reduction is expensive; practical evaluators need graph reduction or supercombinators.
- Debugging: Since everything reduces to functions, mapping back to source-level constructs is non-trivial.

Summerry:
- This implementation demonstrates how λ-calculus can serve as a minimal, uniform IR. Every construct in the source language is lowered into pure function abstraction and application, making the IR simple and mathematically elegant, while highlighting tradeoffs in verbosity and performance.


